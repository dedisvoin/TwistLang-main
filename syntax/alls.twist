let a = 10; # create variable a with value 10 and type Int

let p = Int; # create variable p with value Int and type Type (Int type alias)

let union = Int | Double; # create variable union with value Int | Double (union type) and type Type

outln Int >> union; # true, because Int is a subtype of union

let name = input("Enter name: "); # create variable name with value input from console and type String
# input instruction automatically detect type of input value and return it
# 3.14 - Double
# 3.14sadf - String
# 10 - Int

const let a = 10; # create const variable a with value 10 and type Int
a = 10; # error, because a is const variable

final let b = "Ivan"; # create final variable b with value "Ivan" and type String
b = "Petr"; # true, because b is not const variable
let b = 10; # error, because b is final variable





static let a: Int = 10; # create static variable a with value 10 and type Int
a = 2000; # true
a = 3.14; # error, because a is static variable

static let test: Int | Double = 2.3445; # create static variable test with value 2.3445 and type Int | Double
test = 3.14; # true

static let test2: Int?; # create value with type Int | Null and set value null
test2 = null; # true
test2 = 10; # true


let max = lambda(a: Int, b: Int) -> Int { # create lambda function with parameters a and b and return type Int
    if (a > b) { a } else { b } # if expression
};

let fib = lambda[fib](N: Int) -> Int { # create recursive lambda function with parameter N and return type Int
    if (N == 0) { 0 } else {
        if (N == 1) { 1 } else {
            fib(N - 1) + fib(N - 2)
        }
    }
}
# in the [...] set name of lambda function that set lambda object in lambda memory


namespace std {
    let a = 10; # create variable a with value 10 and type Int
}

outln std::a; # output 10

# dynamic namespace declararation
let std = namespace { # equal to `namespace std { ... }`
    let a = 10; # create variable a with value 10 and type Int
}


global let a = 10; # set global that copyable variable in namespaces and local memoryes
namespace std {
    let b = a * a; # a set as global variable
}


let Person = lambda(name: String, age: Int) -> Namespace { # create class Person with parameters name and age
    namespace {} # name and age arguments automatically copy to namespace
};



let var = 10;
let ptr = &var; # get pointer to var

outln *var; # output 10

*var = 20; # set value 20 to var



let ptr = new 10; # create variable with value 10 and type Int in heap

let ptr = new<const> 10; # create const variable with value 10 and type Int in heap

let ptr = new<static(Int)>; # create static variable with value null and type Int in heap

let ptr = new<static(Int), const> 10 * 2;


func sum(a: Int, b: Int) -> Int { 
    ret a + b;
};


let callable = Func(Int, Int) -> Int; # create function type with parameters Int, Int and return type Int

outln typeof(sum) == callable; # true

outln typeof(callable); # output: Type

for (let i = 0; i < 10; i = i + 1) {
    outln i, i * i;
    if (i == 6) continue;
}


let a = 0;
while (true) {
    a = a + 1;
    if (a > 10) break;
    outln a;
}